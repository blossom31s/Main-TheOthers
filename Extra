
----------< 총괄 >----------

# 목차
- 총괄
- 환경
- 참고
- 알고리즘 종류들..
- PEIM


# 체계
- 자료구조
    Array
    String
    Linked List
    Stack&Queue
    Hash
    Tree
        Heap
    Graph
- 정렬
- 탐색
    DFS
    BFS
- 비트조작
- 수학
    진수 변환
    유클리드 호제법
- 동적계획법(다이나믹 프로그래밍)
- 탐욕법
- Machine Learning
    지도학습
        분류
            Logistic Regression(이진분류)
            Multiclass Classification
        회귀
            Linear Regression
            SVM(Support Vector Machine)
            Decision Tree & Random Forest
            Neural Networks
                CNN
                RNN
    비지도학습
        Clustering
            k-Means
            HCA(Hierarchical Cluster Analysis)
            Expectation Maximization
        Visualization & Dimensionality Reduction
            PCA(Principal Component Analysis)
            kernel PCA
            LLE(Locally-Linear Embedding)
            t-SNE(t-distributed Stochastic Neighbor Embedding)
        Association rule learning
            Apriori
            Eclat
    생성?
        GAN


# 소재
- 도서
    코딩인터뷰 완전분석(인사이트)
    알고리즘 문제 해결 전략 세트(인사이트)
    파이썬 자료구조와 알고리즘(한빛미디어)
    모두의 알고리즘 with 파이썬(길벗)
    누워서 읽는 알고리즘(한빛미디어)
    그림으로 정리한 알고리즘과 자료구조(정보문화사)
    TopCoder 탑코더 알고리즘 트레이닝(한빛미디어)
    밑바닥부터 시작하는 딥러닝(한빛미디어)
    밑바닥부터 시작하는 딥러닝2(한빛미디어)
    블록과 함께하는 파이썬 딥러닝 케라스(디지털북스)
    케라스 창시자에게 배우는 딥러닝(길벗)
    파이썬 머신러닝 완벽가이드(위키북스)
    파이썬 라이브러리를 활용한 머신러닝(한빛미디어)
    파이썬 라이브러리를 활용한 데이터분석(한빛미디어)
- 강좌
    모두의 딥러닝 시즌2(김성훈)
    Coursera
    Edwith
    Inflearn
- Online Judge
    Codility
    LeetCode
    ..



----------< 환경 >----------

# 머신러닝 작업환경 만들기(Anaconda Prompt)
- 아나콘다 설치 : repo.continuum.io/archive/index.html 에서 Anaconda3-5.2.0-Windows-x86_64.exe 다운로드&설치
- Anaconda Prompt 를 '관리자 권한'으로 실행
- 파이썬 버전 확인 : $ python -V
- 아나콘다 버전 확인 : $ conda --version
- 아나콘다 업데이트 : $ conda update -n base conda
- 아나콘다 가상환경 생성 : $ conda create -n '가상환경이름' python='파이썬 버전' # 텐서플로와의 호환을 위해 파이썬 버전은 3.6으로 해야 함
- 아나콘다 가상환경 조회 : $ conda info --envs
- 아나콘다 가상환경 진입 : $ activate '가상환경이름'
- 아나콘다 가상환경 종료 : $ deactivate
- 아나콘다 가상환경 내에 텐서플로&케라스&주피터노트북 설치 : $ conda install tensorflow keras jupyter
- 아나콘다 가상환경 내에 conda 커널 설치 : $ conda install nb_conda
- 아나콘다 가상환경 내에 설치된 패키지 조회 : $ conda list
- 아나콘다 가상환경 내에 텐서플로 설치 확인 : $ python
    import tensorflow as tf
    tf.__version__
    import keras
    keras.__version__
    exit
- 전체 파이썬 패키지 업데이트 : $ conda update --all
- 아나콘다 가상환경 내에서 주피터노트북 실행 : $ jupyter notebook



----------< 참고 >----------

# 알고리즘
- Cracking The Coding Interview : https://github.com/careercup/CtCI-6th-Edition


# 데이터셋 구하기
- 유명한 공개 데이터 저장소
    UC Irvine 머신러닝 저장소 : http://archive.ics.uci.edu/ml/
    Kaggle 데이터셋 : https://www.kaggle.com/datasets
    아마존 AWS 데이터셋 : https://registry.opendata.aws/
- 메타 포털(공개 데이터 저장소가 나열되어 있음)
    http://dataportals.org/
    https://opendatamonitor.eu/
    https://www.quandl.com/
- 인기 있는 공개 데이터 저장소가 나열되어 있는 다른 페이지
    위키백과 머신러닝 데이터셋 목록 : https://en.wikipedia.org/wiki/List_of_datasets_for_machine-learning_research
    Quora.com 질문 : https://www.quora.com/Where-can-I-find-large-datasets-open-to-the-public
    데이터셋 Subreddit : https://www.reddit.com/r/datasets


# References
- 케라스 창시자 책의 예제코드 : https://github.com/rickiepark/deep-learning-with-python-notebooks
- 핸즈온 머신러닝 책의 예제코드 : https://github.com/rickiepark/handson-ml/
- 파이썬 공부 : https://www.learnpython.org/
- 파이썬 공식 튜토리얼 : https://docs.python.org/3/tutorial/
- 머신러닝 강의 by 앤드류 응 : https://www.coursera.org/learn/machine-learning
- 딥러닝 강의 by 앤드류 응 : https://www.coursera.org/specializations/deep-learning
- 데이터퀘스트 : https://www.dataquest.io/
- 쿠오라 : https://www.quora.com/What-are-the-best-regularly-updated-machine-learning-blogs-or-resources-available
- 딥러닝 : http://deeplearning.net/
- nbviewer : https://nbviewer.jupyter.org/github/rickiepark/handson-ml/tree/master/
- 밑바닥부터 시작하는 데이터 과학(인사이트)
- 알고리즘 중심의 머신 러닝가이드(제이펍)
- 파이썬 머신러닝(지앤선)
- 인공지능 1, 2(제이펍)
- cs231n, cs224



----------< BA.? >----------



----------< BA.? >----------



----------< ML.? >----------



----------< ML.? >----------



----------< PEIM >----------



----------< 코딩인터뷰 완전분석(인사이트) >----------

# 자료구조 > 1. 배열과 문자열 > 1. Is_unique.cpp

중복이 없는가:
문자열이 주어졌을 때, 이 문자열에 같은 문자가 중복되어 등장하는지 확인하는 알고리즘을 작성하라.
자료구조를 추가로 사용하지 않고 풀 수 있는 알고리즘 또한 고민하라.

#include <string>
#include <vector>
#include <iostream>
#include <bitset>
using namespace std;

bool isUniqueChars(const string &str){
    if (str.length() > 128){
        return false;
    }
    vector<bool> char_set(128);
    for (int i = 0; i < str.length(); i++){
        int val = str[i];
        if (char_set[val]){
            return false;
        }
        char_set[val] = true;
    }
    return true;
}

bool isUniqueChars_bitvector(const string &str) {
	//Reduce space usage by a factor of 8 using bitvector. 
	//Each boolean otherwise occupies a size of 8 bits.
	bitset<256> bits(0);
	for(int i = 0; i < str.length(); i++) {
		int val = str[i];
		if(bits.test(val) > 0) {
			return false;
		}
		bits.set(val);
	}
	return true;
}
bool isUniqueChars_noDS(const string &str) {
	for(int i = 0; i < str.length()-1; i++) {
		for(int j = i+1; j < str.length(); j++) {
			if(str[i] == str[j]) {
				return false;
			}
		}
	}
	return true;	
}

int main(){
    vector<string> words = {"abcde", "hello", "apple", "kite", "padle"};
    for (auto word : words)
    {
        cout << word << string(": ") << boolalpha << isUniqueChars(word) <<endl;
    }
    cout <<endl << "Using bit vector" <<endl;
    for (auto word : words)
    {
        cout << word << string(": ") << boolalpha << isUniqueChars_bitvector(word) <<endl;
    }
    cout <<endl << "Using no Data Structures" <<endl;
    for (auto word : words)
    {
        cout << word << string(": ") << boolalpha << isUniqueChars_bitvector(word) <<endl;
    }
    return 0;
}


# 자료구조 > 1. 배열과 문자열 > 2. Check_Permutation.cpp

순열 확인:
문자열 두 개가 주어졌을 때 이 둘이 서로 순열 관계에 있는지 확인하는 메서드를 작성하라.

#include <stdio.h>
#include <string.h>
#include <algorithm>
#include <iostream>
using namespace std;
bool arePermutation(string str1,string str2)
{
    // Get lengths of both strings
    int n1 = str1.length();
    int n2 = str2.length();

    // If length of both strings is not same, then they
    // cannot be anagram
    if (n1 != n2)
      return false;

    // Sort both strings
    sort(str1.begin(), str1.end());
    sort(str2.begin(), str2.end());
    // Compare sorted strings
    for (int i = 0; i < n1;  i++)
       if (str1[i] != str2[i])
         return false;

    return true;
}

bool arePermutation_2(const string &str1, const string &str2) {
  if(str1.length() != str2.length()) 
    return false;
  int count[256]={0};
  for(int i = 0; i < str1.length(); i++) {
    int val = str1[i];
    count[val]++;
  }
  for(int i = 0; i < str2.length(); i++) {
    int val = str2[i];
    count[val]--;
    if(count[val]<0) 
      return false;
  }
  return true;
}

int main() {
// Test Method 1 - Using sort
    cout << "Method 1 - Using sort" << endl;
    string str1 = "testest";
    string str2 = "estxest";
    if(arePermutation(str1, str2))
      cout << str1 <<" and " << str2 << " are permutation of each other" << endl;
    else
      cout << str1 <<" and " << str2 << " are not permutation of each other" << endl;
    str1 = "hello";
    str2 = "oellh";
    if(arePermutation(str1, str2))
      cout << str1 <<" and " << str2 << " are permutation of each other" << endl;
    else
      cout << str1 <<" and " << str2 << " are not permutation of each other" << endl;

//Test Method 2 - Using character count
    cout << "Method 2 - Using character count" << endl;
    str1 = "testest";
    str2 = "estxest";
    if(arePermutation_2(str1, str2))
      cout << str1 <<" and " << str2 << " are permutation of each other" << endl;
    else
      cout << str1 <<" and " << str2 << " are not permutation of each other" << endl;
    str1 = "hello";
    str2 = "oellh";
     if(arePermutation_2(str1, str2))
      cout << str1 <<" and " << str2 << " are permutation of each other" << endl;
    else
      cout << str1 <<" and " << str2 << " are not permutation of each other" << endl;
    return 0;
}


# 자료구조 > 1. 배열과 문자열 > 3. URLify.cpp

URLify:
문자열에 들어 있는 모든 공백을 '%20'으로 바꾸는 메서드를 작성하라.
최종적으로 모든 문자를 다 담을 수 있을 만큼 충분한 공간이 이미 확보되어 있으며
문자열의 최종 길이가 함께 주어진다고 가정해도 된다
(자바로 구현한다면 배열 안에서 작업할 수 있도록 문자 배열(character array)을 이용하라).

/*
 * Cracking the coding interview Edition 6
 * Problem 1.3 URLify --> Replace all the spaces in a string with '%20'. 
 * Assumption : We have enough space to accomodate addition chars
 * Preferebly in place
 */

#include <iostream>
#include <cstring>

/*
 * Function : urlify
 * Args     : string long enough to accomodate extra chars + true len 
 * Return   : void (in place transformation of string)
 */

void urlify(char *str, int len)
{
    int numOfSpaces = 0;
    int i = 0, j = 0;
    for ( i = 0; i < len; ++i ) {
        if (str[i] == ' ') {
            ++numOfSpaces;
        }
    }
    
    int extendedLen  = len + 2 * numOfSpaces;
    i = extendedLen - 1;
    for( j = len - 1; j >= 0; --j ) {
        if ( str[j] != ' ' ) {
            str[i--] = str[j];
        } else {
            str[i--] = '0';
            str[i--] = '2';
            str[i--] = '%';
        }
    }
}

int main()
{
    char str[] = "Mr John Smith    ";                       //String with extended length ( true length + 2* spaces)
    std::cout << "Actual string   : " << str << std::endl;
    urlify(str, 13);                                        //Length of "Mr John Smith" = 13
    std::cout << "URLified string : " << str << std::endl;
    return 0;
}


# 자료구조 > 1. 배열과 문자열 > 4. 

회문 순열:
주어진 문자열이 회문(palindrome)의 순열인지 아닌지 확인하는 함수를 작성하라.
회문이란 앞으로 읽으나 뒤로 읽으나 같은 단어 혹은 구절을 의미하며,
순열이란 문자열을 재배치하는 것을 뜻한다.
회문이 꼭 사전에 등장하는 단어로 제한될 필요는 없다.

※ 예제
입력: tact coa
출력: True (순열: "taco cat", "atco cta" 등등)

/*
 * Cracking the coding interview edition 6
 * Given a string, write a function to check if it is a permutation of a pallindrome.
 *
 * Solution Philosophy:
 * For a string to be pallindrome, it should be able to spelled backward and forward the same.
 * Therefore the chars in string should fit one of the two possibilities:
 *  - Each char appear even number of times in the string ( even length string )
 *  - Each char should appear even number of times, except just one char ( odd length string )
 * 
 * We won't care about the case of the letter
 */

#include <iostream>

/*
 * Helper routine to return an frequency Table index
 *
 */

int getCharIndex( char c )
{
    int idx = -1;
    if ( c >= 'a' && c <= 'z' )
    {
        idx = c - 'a';
    }
    else if ( c >= 'A' && c <= 'Z' )
    {
        idx = c - 'A';
    }
    return idx;
}

/*
 * Function : countFrequency
 * Args     : input string, an array of int 
 * Return   : Void, array of int will populate each letter's frequency in string.
 */

void countFrequency( const std::string & str, int *frequency )
{
    int idx;
    for (const char & c : str)
    {
        idx = getCharIndex(c);
        if ( idx != -1 )
        {
            ++frequency[idx];
        }
    }
}

/*
 * Function : isPermutePallindrome 
 * Args     : input string
 * Return   : returns true if is possible that one of the permutations of input string can be a pallindrome.
 *            else return false
 */

bool isPermutationOfPallindrome1( const std::string & str )
{
    int frequency[ 26 ] = { 0 };
    countFrequency( str, frequency );

    /*
     * We will check here that letter frequencies are all even or all even except one odd.
     */
    bool oddAppeared = false;
    std::cout << std::endl;
    for ( int i = 0 ; i < 26; ++i ) {
        if ( frequency[i] % 2  && oddAppeared ) {
            return false;
        } else if ( frequency[i] % 2 && !oddAppeared ) {
            oddAppeared = true;
        }
    }
    return true;
}

/*
 * Approach 2:
 * Let us optimize above function instead of taking another pass let us do it
 * in one go, we will count odd chars as we go along, if we are left with 
 * more that 0 or 1, then the input string can't have pallindrome permutation
 */

bool isPermutationOfPallindrome2( const std::string & str )
{
    int oddCount = 0;
    int frequency[26] = { 0 };
    int idx = 0;
    for ( const char & c : str )
    {
        idx = getCharIndex(c);
        if ( idx != -1 )
        {
            ++frequency[idx];
            if ( frequency[idx] % 2 ) 
            {   
                ++oddCount;
            } else {
                --oddCount;
            }
        }
    }
    return (oddCount <= 1);
}

/*
 * Approach 3
 * let us represent each char with a bit in a bitvector
 * Each time a char appears in the string we toggle the
 * respective bit, if we are left with more than 1 bit
 * in the bit vector, the string can not have a pallidrome
 * permutation.
 *
 */

/*
 * helper function to toggle a bit in the integer
 */ 

int toggle( int bitVector, int index )
{
    if ( index < 0 )
        return bitVector;

    int mask = 1 << index;
    //if bit is not set
    if ( (bitVector & mask ) == 0 )
    {
        bitVector |= mask;
    } else {    //if bit is set
        bitVector &= ~mask;
    }
    return bitVector;
}

/*
 * Helper functiont to find if a single bit is set
 * i.e. if bitVector is a multiple of power of 2
 */

bool isExactlyOneBitSet( int bitVector )
{
    return ( (bitVector & (bitVector - 1)) == 0 );
}

/*
 * Third approach solution
 * toggle bit represent the respective char 
 * for each appearance in the string.
 */

bool isPermutationOfPallindrome3( const std::string & str )
{
    int bitVector = 0;
    int id = 0;
    for ( const char & c : str )
    {
        id = getCharIndex(c);
        bitVector = toggle (bitVector, id );
    }
    return ( bitVector == 0 || isExactlyOneBitSet(bitVector) );
}

int main()
{
    std::string str("Tact Coa");
    std::cout << "Does \"" << str << "\"  has a string whose permutation is a pallindrome? "
              << "( 1 for true, 0 for false ) : ";
    std::cout << "Approach 1:" << isPermutationOfPallindrome1( str ) << std::endl;
    std::cout << "Approach 2:" << isPermutationOfPallindrome2( str ) << std::endl;
    std::cout << "Approach 3:" << isPermutationOfPallindrome3( str ) << std::endl;

    std::string str1("A big Cat");
    std::cout << "Does \"" << str1 << "\" has a string whose permutation is a pallindrome? "
              << "( 1 for true, 0 for false ) : ";
    std::cout << "Approach 1:" << isPermutationOfPallindrome1( str1 ) << std::endl;
    std::cout << "Approach 2:" << isPermutationOfPallindrome2( str1 ) << std::endl;
    std::cout << "Approach 3:" << isPermutationOfPallindrome3( str1 ) << std::endl;

    std::string str2("Aba cbc");
    std::cout << "Does \"" << str2 << "\" has a string whose permutation is a pallindrome? "
              << "( 1 for true, 0 for false ) : ";
    std::cout << "Approach 1:" << isPermutationOfPallindrome1( str2 ) << std::endl;
    std::cout << "Approach 2:" << isPermutationOfPallindrome2( str2 ) << std::endl;
    std::cout << "Approach 3:" << isPermutationOfPallindrome3( str2 ) << std::endl;
    return 0;
}


# 자료구조 > 1. 배열과 문자열 > 5. 

하나 빼기:
문자열을 편집하는 방법에는 세 가지 종류가 있다.
문자 삽입, 문자 삭제, 문자 교체.
문자열 두 개가 주어졌을 때,
문자열을 같게 만들기 위한 편집 횟수가 1회 이내인지 확인하는 함수를 작성하라.

※ 예제
pale, ple -> true
pales, pale -> true
pale, bale -> true
pale, bake -> false


# 자료구조 > 1. 배열과 문자열 > 6. 

문자열 압축:
반복되는 문자의 개수를 세는 방식의 기본적인 문자열 압축 메서드를 작성하라.
예를 들어 문자열 aabccccaaa를 압축하면 a2b1c4a3이 된다.
만약 '압축된' 문자열의 길이가 기존 문자열의 길이보다 길다면 기존 문자열을 반환해야 한다.
문자열은 대소문자 알파벳(a~z)으로만 이루어져 있다.


# 자료구조 > 1. 배열과 문자열 > 7. 

행렬 회전:
이미지를 표현하는 N×N 행렬이 있다.
이미지의 각 픽셀은 4바이트로 표현된다.
이때, 이미지를 90도 회전시키는 메서드를 작성하라.
행렬을 추가로 사용하지 않고서도 할 수 있겠는가?


# 자료구조 > 1. 배열과 문자열 > 8. 

0 행렬:
M×N 행렬의 한 원소가 0일 경우,
해당 원소가 속한 행과 열의 모든 원소를 0으로 설정하는 알고리즘을 작성하라.


# 자료구조 > 1. 배열과 문자열 > 9. 

문자열 회전:
한 단어가 다른 문자열에 포함되어 있는지 판별하는 isSubstring 이라는 메서드가 있다고 하자.
s1과 s2의 두 문자열이 주어졌고, s2가 s1을 회전시킨 결과인지 판별하고자 한다
(가령 'waterbottle'은 'erbottlewat'을 회전시켜 얻을 수 있는 문자열이다).
isSubstring 메서드를 한 번만 호출해서 판별할 수 있는 코드를 작성하라.


# 자료구조 > 2. 연결리스트 > 1. 

중복 없애기:
정렬되어 있지 않은 연결리스트가 주어졌을 때
이 리스트에서 중복되는 원소를 제거하는 코드를 작성하라.


# 자료구조 > 2. 연결리스트 > 2. 

뒤에서 k번째 원소 구하기:
단방향 연결리스트가 주어졌을 때 뒤에서 k번째 원소를 찾는 알고리즘을 구현하라.


# 자료구조 > 2. 연결리스트 > 3. 

중간 노드 삭제:
단방향 연결리스트가 주어졌을 때 중간
(정확히 가운데 노드일 필요는 없고 처음과 끝 노드만 아니면 된다)에 있는
노드 하나를 삭제하는 알고리즘을 구현하라.
단, 삭제할 노드에만 접근할 수 있다.


# 자료구조 > 2. 연결리스트 > 4. 

분할:
값 x가 주어졌을 때 x보다 작은 노드들을
x보다 크거나 같은 노드들보다 앞에 오도록 하는 코드를 작성하라.
만약 x가 리스트에 있다면 x는 그보다 작은 원소들보다 뒤에 나오기만 하면 된다.
즉, 원소 x는 '오른쪽 그룹' 어딘가에만 존재하면 된다.
왼쪽과 오른쪽 그룹 사이에 있을 필요는 없다.


# 자료구조 > 2. 연결리스트 > 5. 

리스트의 합:
연결리스트로 숫자를 표현할 때 각 노드가 자릿수 하나를 가리키는 방식으로 표현할 수 있다.
각 숫자는 역순으로 배열되어 있는데,
즉, 첫 번째 자릿수가 리스트의 맨 앞에 위치하도록 배열된다는 뜻이다.
이와 같은 방식으로 표현된 숫자 두 개가 있을 때,
이 두 수를 더하여 그 합을 연결리스트로 반환하는 함수를 작성하라.

※ 예제
입력: (7→1→6) + (5→9→2). 즉, 617 + 295
출력: (2→1→9). 즉, 912


# 자료구조 > 2. 연결리스트 > 6. 

회문:
주어진 연결리스트가 회문(palindrome)인지 검사하는 함수를 작성하라.


# 자료구조 > 2. 연결리스트 > 7. 

교집합:
단방향 연결리스트 두 개가 주어졌을 때
이 두 리스트의 교집합 노드를 찾은 뒤 반환하는 코드를 작성하라.
여기서 교집합이란 노드의 값이 아니라 노드의 주소가 완전히 같은 경우를 말한다.
즉, 첫 번째 리스트에 있는 k번째 노드와 두 번째 리스트에 있는 j번째 노드가
주소까지 완전히 같다면 이 노드는 교집합의 원소가 된다.


# 자료구조 > 2. 연결리스트 > 8. 

루프 발견:
순환 연결리스트(circular linked list)가 주어졌을 때,
순환되는 부분의 첫째 노드를 반호나하는 알고리즘을 작성하라.
순환 연결리스트란 노드의 next 포인터가
앞선 노드들 가운데 어느 하나를 가리키도록 설정되어 있는,
엄밀히 말해서는 변질된 방식의 연결리스트를 의미한다.

※ 예제
입력: A→B→C→D→E→C (앞에 나온 C와 같음)
출력: C


# 자료구조 > 3. 스택과 큐 > 1. 

한 개로 세 개:
배열 한 개로 스택 세 개를 어떻게 구현할지 설명하라.


# 자료구조 > 3. 스택과 큐 > 2. 

스택 Min:
기본적인 push와 pop 기능이 구현된 스택에서 최솟값을 반환하는 min 함수를 추가하려고 한다.
어떻게 설계할 수 있겠는가?
push, pop, min 연산은 모두 O(1) 시간에 동작해야 한다.


# 자료구조 > 3. 스택과 큐 > 3. 

접시 무더기:
접시 무더기를 생각해 보자.
접시를 너무 높이 쌓으면 무너져 내릴 것이다.
따라서 현실에서는 접시를 쌓다가 무더기 높이가 어느 정도 높아지면 새로운 무더기를 만든다.
이것을 흉내 내는 자료구조 SetOfStacks를 구현해 보라.
SetOfStacks는 여러 개의 스택으로 구성되어 있으며,
이전 스택이 지정된 용량을 초과하는 경우 새로운 스택을 생성해야 한다.
SetOfStacks.push()와 SetOfStacks.pop()은 스택이 하나인 경우와 동일하게 동작해야 한다
(다시 말해, pop()은 정확히 하나의 스택이 있을 때와 동일한 값을 반환해야 한다).


# 자료구조 > 3. 스택과 큐 > 4. 

스택으로 큐:
스택 두 개로 큐 하나를 구현한 MyQueue 클래스를 구현하라.


# 자료구조 > 3. 스택과 큐 > 5. 

스택 정렬:
가장 작은 값이 위로 오도록 스택을 정렬하는 프로그램을 작성하라.
추가적으로 하나 정도의 스택은 사용해도 괜찮지만,
스택에 보관된 요소를 배열 등의 다른 자료구조로 복사할 수는 없다.
스택은 push, pop, peek, isEmpty의 네 가지 연산을 제공해야 한다.


# 자료구조 > 3. 스택과 큐 > 6. 

동물 보호소:
먼저 들어온 동물이 먼저 나가는 동물 보호소(animal shelter)가 있다고 하자.
이 보호소는 개와 고양이만 수용한다.
사람들은 보호소에서 가장 오래된 동물부터 입양할 수 있는데,
개와 고양이 중 어떤 동물을 데려갈지 선택할 수 있다.
하지만 특정한 동물을 지정해 데려갈 수는 없다.
이 시스템을 자료구조로 구현하라.
이 자료구조는 enqueue. dequeueAny, dequeueDog, dequeueCat의 연산을 제공해야 한다.
기본적으로 탑재되어 있는 LinkedList 자료구조를 사용해도 좋다.


# 자료구조 > 4. 트리와 그래프 > 1. 

노드 사이의 경로:
방향 그래프가 주어졌을 때 두 노드 사이에 경로가 존재하는지 확인하는 알고리즘을 작성하라.


# 자료구조 > 4. 트리와 그래프 > 2. 

최소 트리:
오름차순으로 정렬된 배열이 있다.
이 배열 안에 들어 있는 원소는 정수이며 중복된 값이 없다고 했을 때
높이가 최소가 되는 이진 탐색 트리를 만드는 알고리즘을 작성하라.


# 자료구조 > 4. 트리와 그래프 > 3. 

깊이의 리스트:
이진 트리가 주어졌을 때 같은 깊이에 있는 노드를 연결리스트로 연결해 주는 알고리즘을 설계하라.
즉, 트리의 깊이가 D라면 D개의 연결리스트를 만들어야 한다.


# 자료구조 > 4. 트리와 그래프 > 4. 

균형 확인:
이진 트리가 균형 잡혀있는지 확인하는 함수를 작성하라.
이 문제에서 균형 잡힌 트리란 모든 노드에 대해서
왼쪽 부분 트리의 높이와 오른쪽 부분 트리의 높이의 차이가 최대 하나인 트리를 의미한다.


# 자료구조 > 4. 트리와 그래프 > 5. 

BST 검증:
주어진 이진 트리가 이진 탐색 트리인지 확인하는 함수를 작성하라.


# 자료구조 > 4. 트리와 그래프 > 6. 

후속자:
이진 탐색 트리에서 주어진 노드의
'다음'노드(중위 후속자(in-order successor))를 찾는 알고리즘을 작성하라.
각 노드에는 부모 노드를 가리키는 링크가 존재한다고 가정하자.


# 자료구조 > 4. 트리와 그래프 > 7. 

순서 정하기:
프로젝트의 리스트와 프로젝트들 간의 종속 관계
(즉, 프로젝트 쌍이 리스트로 주어지면 각 프로젝트 쌍에서
두 번째 프로젝트가 첫 번째 프로젝트에 종속되어 있다는 뜻)가 주어졌을 때,
프로젝트를 수행해 나가는 순서를 찾으라.
유효한 순서가 존재하지 않으면 에러를 반환한다.

※ 예제
입력:
    프로젝트: a, b, c, d, e, f
    종속 관계: (a, d), (f, b), (b, d), (f, a), (d, c)
출력: f, e, a, b, d, c


# 자료구조 > 4. 트리와 그래프 > 8. 

첫 번째 공통 조상:
이진 트리에서 노드 두 개가 주어졌을 때
이 두 노드의 첫 번째 공통 조상을 찾는 알고리즘을 설계하고 그 코드를 작성하라.
자료구조 내에 추가로 노드를 저장해 두면 안 된다.
반드시 이진 탐색 트리일 필요는 없다.


# 자료구조 > 4. 트리와 그래프 > 9. 

BST 수열:
배열의 원소를 왼쪽에서부터 차례로 트리에 삽입함으로써 이진 탐색 트리를 생성할 수 있다.
이진 탐색 트리 안에서 원소가 중복되지 않는다고 할 때,
해당 트리를 만들어 낼 수 있는 가능한 배열을 모두 출력하라.

※ 예제
입력: (1) ← (2) → (3)
출력: {2, 1, 3}, {2, 3, 1}


# 자료구조 > 4. 트리와 그래프 > 10. 

하위 트리 확인:
두 개의 커다란 이진 트리 T1과 T2가 있다고 하자.
T1이 T2 보다 훨씬 크다고 했을 때,
T2가 T1의 하위 트리(subtree)인지 판별하는 알고리즘을 만들라.
T1 안에 있는 노드 n의 하위 트리가 T2와 동일하면, T2는 T1의 하위 트리다.
다시 말해, T1에서 노드 n의 아래쪽을 끊어 냈을 때 그 결과가 T2와 동일해야 한다.


# 자료구조 > 4. 트리와 그래프 > 11. 

임의의 노드:
이진 트리 클래스를 바닥부터 구현하려고 한다.
노드의 삽입, 검색, 삭제뿐만 아니라 임의의 노드를 반환하는 getRandomNode() 메서드도 구현한다.
모든 노드를 같은 확률로 선택해주는 getRandomNode 메서드를 설계하고 구현하라.
또한 나머지 메서드는 어떻게 구현할지 설명하라.


# 자료구조 > 4. 트리와 그래프 > 12. 

합의 경로:
각 노드의 값이 정수(음수 및 양수)인 이진 트리가 있다.
이때 정수의 합이 특정 값이 되도록 하는 경로의 개수를 세려고 한다.
경로가 꼭 루트에서 시작해서 말단 노드에서 끝날 필요는 없지만 반드시 아래로 내려가야 한다.
즉, 부모 노드에서 자식 노드로만 움직일 수 있다. 알고리즘을 어떻게 설계할 것인가?


# 개념과 알고리즘 > 5. 비트 조작 > 1. 

삽입:
두 개의 32비트 수 N과 M이 주어지고, 비트 위치 i와 j가 주어졌을 때,
M을 N에 삽입하는 메서드를 구현하라.
M은 N의 j번째 비트에서시작하여 i번째 비트에서 끝난다.
j번째 비트에서 i번째 비트까지에는 M을 담기 충분한 공간이 있다고 가정한다.
다시 말해, M = 10011라면, j와 i 사이에 적어도 다섯 비트가 있다고 가정해도 된다는 것이다.
j=3이고 i=2인 경우처럼 M을 삽입할 수 없는 상황은 생기지 않는다고 봐도 된다.


# 개념과 알고리즘 > 5. 비트 조작 > 2. 

2진수를 문자열로:
0.72와 같이 0과 1 사이의 실수가 double 타입으로 주어졌을 때,
그 값을 2진수 형태로 출력하는 코드를 작성하라.
길이가 32 이하인 문자열로 2진수로 정확하게 표현할 수 없다면 ERROR를 출력하라.


# 개념과 알고리즘 > 5. 비트 조작 > 3. 

비트 뒤집기:
어떤 정수가 주어졌을 때 여러분은 이 정수의 비트 하나를 0에서 1로 바꿀 수 있다.
이때 1이 연속으로 나올 수 있는 가장 긴 길이를 구하는 코드를 작성하라.

※ 예제
입력: 1775 (혹은 11011101111)
출력: 8


# 개념과 알고리즘 > 5. 비트 조작 > 4. 

다음 숫자:
양의 정수가 하나 주어졌다.
이 숫자를 2진수로 표기했을 때 1비트의 개수가 같은 숫자 중에서
가장 작은 수와 가장 큰 수를 구하라.


# 개념과 알고리즘 > 5. 비트 조작 > 5. 

디버거:
다음 코드가 하는 일을 설명하라.
((n & (n-1)) == 0)


# 개념과 알고리즘 > 5. 비트 조작 > 6. 

변환:
정수 A와 B를 2진수로 표현했을 때,
A를 B로 바꾸기 위해 뒤집어야 하는 비트의 개수를 구하는 함수를 작성하라.

※ 예제
입력: 29 (혹은 11101), 15(혹은 01111)
출력: 2


# 개념과 알고리즘 > 5. 비트 조작 > 7. 

쌍끼리 맞바꾸기:
명령어를 가능한 한 적게 사용해서
주어진 정수의 짝수 번째 비트의 값과 홀수 번째 비트의 값을 바꾸는 프로그램을 작성하라
(예: 0번째 비트와 1번째 비트를 바꾸고, 2번째 비트와 3번째 비트를 바꾸는 식으로).


# 개념과 알고리즘 > 5. 비트 조작 > 8. 

선 그리기:
흑백 모니터 화면은 하나의 바이트 배열에 저장되는데,
인접한 픽셀 여덟 개를 한 바이트에 묶어서 저장한다.
화면의 폭은 w이며, w는 8로 나누어 떨어진다(따라서 어떤 바이트도 두 행에 걸치지 않는다).
물론, 화면 높이는 배열 길이와 화면 폭을 통해 유도해 낼 수 있다.
이때 (x1, y)에서 (x2, y)까지 수평선을 그려주는 함수를 작성하라.
메서드 용법(method signature)은 다음과 같다.
drawLine(byte[] screen, int width, int x1, int x2, int y)


# 개념과 알고리즘 > 6. 수학 및 논리 퍼즐 > 1. 

무거운 알약:
약병 20개가 있다.
이 중 19개에는 1.0그램짜리 알약들이 들어있고, 하나에는 1.1그램짜리 알약들이 들어 있다.
정확한 저울 하나가 주어졌을 때, 무거운 약병을 찾으려면 어떻게 해야 할까?
저울은 딱 한 번만 쓸 수 있다.


# 개념과 알고리즘 > 6. 수학 및 논리 퍼즐 > 2. 

농구:
농구 골대가 하나 있는데 다음 두 게임 중 하나를 해볼 수 있다.
게임 1: 슛을 한 번 쏴서 골대에 넣어야 한다.
게임 2: 슛을 세 번 쏴서 두 번 골대에 넣어야 한다.
슛을 넣을 확률을 p라고 했을 때 p가 어떤 값일 때
첫 번째 게임을, 혹은 두 번째 게임을 선택하겠는가?


# 개념과 알고리즘 > 6. 수학 및 논리 퍼즐 > 3. 

도미노:
8×8 크기의 체스판이 있는데, 대각선 반대 방향 끝에 있는 셀(cell) 두 개가 떨어져 나갔다.
하나의 도미노로 정확히 두 개의 정사각형을 덮을 수 있을 때,
31개의 도미노로 보드 전체를 덮을 수 있겠는가?
여러분의 답이 옳다는 것을 증명하라.
예를 들거나, 왜 가능 혹은 불가능한지를 보이면 된다.


# 개념과 알고리즘 > 6. 수학 및 논리 퍼즐 > 4. 

삼각형 위의 개미:
개미 세 마리가 삼각형의 각 꼭짓점에 있다.
개미 세 마리가 삼각형 모서리를 따라 걷기 시작했을 때,
두 마리 혹은 세 마리 전부가 충돌할 확률은 얼마인가?
각 개미는 자신이 움직일 방향을 임의로 선택할 수 있는데,
같은 확률로 두 방향 중 하나를 선택한다.
또한 그들은 같은 속도로 걷는다.
이 문제를 확장해서 n개의 개미가 n각형 위에 있을 때 그들이 충돌할 확률도 구하라.


# 개념과 알고리즘 > 6. 수학 및 논리 퍼즐 > 5. 

물병:
5리터짜리 물병과 3리터짜리 물병이 있다.
물은 무제한으로 주어지지만 계량컵은 주어지지 않는다.
이 물병 두 개를 사용해서 정확히 4리터의 물을 계량하려면 어떻게 해야 할까?
물병의 형태가 좀 괴상해서, 물을 정확히 '절반만' 담는 것 따위는 불가능하다.


# 개념과 알고리즘 > 6. 수학 및 논리 퍼즐 > 6. 

푸른 눈동자의 섬:
어떤 섬에 이상한 명령서를 든 방문자가 찾아왔다.
이 섬에 사는 사람들 중에서 눈동자가 푸른 사람들은
"모두 함께" 매일 저녁 8시에 출발하는 비행기를 타고 섬을 떠나야 한다.
사람들은 남의 눈동자 색은 볼 수 있지만 자신의 눈동자 색은 볼 수 없다.
또한 다른 사람의 눈동자 색을 발설해서는 안 된다.
그들은 적어도 한 명의 눈동자 색이 푸르다는 사실은 알지만, 정확히 몇 명인지는 모른다.
눈동자가 푸른 사람을 모두 떠나보내는 데 최소 며칠이 필요하겠는가?


# 개념과 알고리즘 > 6. 수학 및 논리 퍼즐 > 7. 

대재앙:
대재앙 이후에 여왕은 출산율 때문에 근심이 이만저만이 아니다.
그래서 그녀는 모든 가족은 여자 아이 하나를 낳거나
어마어마한 벌금을 내야 한다는 법령을 만들어 발표했다.
만약 모든 가족이 이 정책을 따른다면(즉, 여자 아이 한 명을 낳을 때까지 아이를 계속 낳는다면)
다음 세대의 남녀 비율은 어떻게 되겠는가?
남자 혹은 여자를 임신할 확률은 같다고 가정한다.
논리적으로 이 문제를 푼 뒤에 컴퓨터로 시뮬레이션해 보라.


# 개념과 알고리즘 > 6. 수학 및 논리 퍼즐 > 8. 

계란 떨어뜨리기 문제:
100층짜리 건물이 있다.
N층 혹은 그 위 어딘가에서 계란이 떨어지면 그 계란은 부서진다.
하지만 N층 아래 어딘가에서 떨어지면 깨지지 않는다.
계란 두 개가 주어졌을 때, 최소 횟수로 계란을 떨어뜨려서 N을 찾으라.


# 개념과 알고리즘 > 6. 수학 및 논리 퍼즐 > 9. 

100 라커:
복도에 100개의 라커가 있다.
어떤 남자가 100개의 라커 문을 전부 연다.
그러고 나서 짝수 번호의 라커를 전부 닫는다.
그 다음에는 번호가 3의 배수인 라커를 순서대로 찾아다니며 열려 있으면 닫고, 닫혀 있으면 연다.
이런 식으로 100번 지나가면(마지막에는 100번째 라커의 문을 열거나 닫을 것이다)
열린 라커문은 몇 개가 되겠는가?


# 개념과 알고리즘 > 6. 수학 및 논리 퍼즐 > 10. 

독극물:
1,000개의 음료수 중 하나에 독극물이 들어 있다.
그리고 독극물을 확인해 볼 수 있는 식별기 10개가 주어졌다.
독극물 한 방울을 식별기에 떨어뜨리면 식별기가 변한다.
만약 식별기에 독극물을 떨어뜨리지 않았다면 몇 번이든 재사용해도 된다.
하지만 이 테스트는 하루에 한 번만 할 수 있으며 결과를 얻기까지 일주일이 걸린다.
독극물이 든 음료수를 가능한 한 빨리 찾아내려면 어떻게 해야 할까?


# 개념과 알고리즘 > 7. 객체 지향 설계 > 1. 

카드 한 벌:
카드 게임에 쓰이는 카드 한 벌을 나타내는 자료구조를 설계하라.
그리고 블랙잭 게임을 구현하려면 이 자료구조의 하위 클래스를 어떻게 만들어야 하는지 설명하라.


# 개념과 알고리즘 > 7. 객체 지향 설계 > 2. 

콜 센터:
고객 응대 담당자, 관리자, 감독관
이렇게 세 부류의 직원들로 구성된 콜 센터가 있다고 하자.
콜 센터로 오는 전화는 먼저 상담이 가능한 고객 응대 담당자로 연결돼야 한다.
고객 응대 담당자가 처리할 수 없는 전화는 관리자로 연결되고,
관리자가 처리할 수 없는 전화는 다시 감독관에게 연결된다.
이 문제를 풀기 위한 자료구조를 설계하라.
응대 가능한 첫 번째 직원에게 전화를 연결시키는 dispatchCall() 메서드를 구현하라.


# 개념과 알고리즘 > 7. 객체 지향 설계 > 3. 

주크박스:
객체 지향 원칙에 따라 음악용 주크박스(musical jukebox)를 설계하라.


# 개념과 알고리즘 > 7. 객체 지향 설계 > 4. 

주차장:
객체 지향 원칙에 따라 주차장(parking lot)을 설계하라.


# 개념과 알고리즘 > 7. 객체 지향 설계 > 5. 

온라인 북 리더:
온라인 북 리더(online book reader) 시스템에 대한 자료구조를 설계하라.


# 개념과 알고리즘 > 7. 객체 지향 설계 > 6. 

직소:
N×N 크기의 직소(jigsaw) 퍼즐을 구현하라.
자료구조를 설계하고, 퍼즐을 푸는 알고리즘을 설명하라.
두 조각의 모서리가 주어졌을 때 그들이 들어맞는지 아닌지 알려주는 fitsWith 메서드는 제공된다.


# 개념과 알고리즘 > 7. 객체 지향 설계 > 7. 

채팅 서버:
채팅 서버를 어떻게 구현할 것인지 설명하라.
특히, 다양한 백엔드 컴포넌트, 클래스, 메서드에 대해 자세히 설명하라.
어떤 문제가 가장 풀기 어려울 것으로 예상되는가?


# 개념과 알고리즘 > 7. 객체 지향 설계 > 8. 

오셀로:
오셀로(Othello) 게임 규칙은 이러하다.
오셀로 말의 한쪽 면은 흰색, 반대 면은 검은색이다.
상대편 말에게 왼쪽과 오른쪽, 또는 위와 아래가 포위된 말은
색상을 뒤집어 상대편 말이 된 것으로 표시된다.
여러분은 여러분 차례에서 적어도 상대편 말 한 개를 획득해야 한다.
더 이상 진행이 불가능해지면 게임은 종료된다.
가장 많은 말을 획득한 사람이 승자가 된다.
이 게임을 객체 지향적으로 설계하라.


# 개념과 알고리즘 > 7. 객체 지향 설계 > 9. 

순환 배열:
CircularArray 클래스를 구현하라.
이 클래스는 배열과 비슷한 자료구조이지만 효과적으로 순환(rotate)이 가능해야 한다.
클래스는 가능하면 제네릭 타입(generic type) 혹은 템플릿(template)으로 구현되는 게 좋고,
for (Obj o : circularArray)와 같이 표준 표기법으로 순회(iterate)가 가능해야 한다.


# 개념과 알고리즘 > 7. 객체 지향 설계 > 10. 

지뢰찾기:
텍스트 기반의 지뢰찾기(Minesweeper) 게임을 설계하고 구현하라.
지뢰찾기는 N×N 격자판에 숨겨진 B개의 지뢰를 찾는 고전적인 컴퓨터 게임이다.
지뢰가 없는 셀(cell)에는 아무것도 적혀 있지 않거나
인접한 여덟 방향에 숨겨진 지뢰의 개수가 적혀 있다.
플레이어는 각 셀을 확인해 볼 수 있는데, 확인한 셀에 지뢰가 있다면 그 즉시 게임에서 진다.
확인한 셀에 숫자가 적혀 있다면 그 값이 공개된다.
해당 셀이 비어있다면 인접한 비어 있는 셀(숫자로 둘러싸인 셀을 만나기 전까지) 또한 모두 공개된다.
지뢰가 없는 셀을 전부 공개된 상태로 바꿔 놓으면 플레이어가 이긴다.
지뢰가 있을 것 같은 위치에 깃발을 꽂아 표시해 둘 수 있는데,
깃발을 곶는 것은 게임에 아무런 영향을 미치지 않는다.
실수로 잘못 클릭하는 상황을 방지하기 위한 기능일 뿐이다
(이 게임에 대해 잘 모른다면, 미리 몇 번 해보길 바란다).


# 개념과 알고리즘 > 7. 객체 지향 설계 > 11. 

파일 시스템:
메모리 상주형 파일 시스템(in-memory file system)을 구현하기 위한
자료구조와 알고리즘에 대해 설명해 보라.
가능하면 코드 예제를 들어 설명하라.


# 개념과 알고리즘 > 7. 객체 지향 설계 > 12. 

해시테이블:
체인(chain 즉 연결리스트)을 사용해 충돌을 해결하는 해시테이블을 설계하고 구현하라.


# 개념과 알고리즘 > 8. 재귀와 동적 프로그래밍 > 1. 

트리플 스텝:
어떤 아이가 n개의 계단을 오른다.
한 번에 1계단 오르기도 하고, 2계단이나 3계단을 오르기도 한다.
계단을 오르는 방법이 몇 가지가 있는지 계산하는 메서드를 구현하라.


# 개념과 알고리즘 > 8. 재귀와 동적 프로그래밍 > 2. 

격자판(grid) 상의 로봇:
행의 개수는 r, 열의 개수는 c인 격자판의 왼쪽 상단 꼭지점에 로봇이 놓여 있다고 상상해 보자.
이 로봇은 오른쪽 아니면 아래쪽으로만 이동할 수 있다.
하지만 어떤 셀(cell)은 '금지 구역'으로 지정되어 있어서 로봇이 접근할 수 없다.
왼쪽 상단 꼭짓점에서 오른쪽 하단 꼭짓점으로의 경로를 찾는 알고리즘을 설계하라.


# 개념과 알고리즘 > 8. 재귀와 동적 프로그래밍 > 3. 

마술 인덱스:
배열 A[0 ... n-1]에서 A[i] = i인 인덱스를 마술 인덱스(magic index)라 정의한다.
정렬된 상태의 배열이 주어졌을 때, 마술 인덱스가 존재한다면 그 값을 찾는 메서드를 작성하라.
배열 안에 중복된 값은 없다.


# 개념과 알고리즘 > 8. 재귀와 동적 프로그래밍 > 4. 

부분집합:
어떤 집합의 부분집합을 전부 반환하는 메서드를 작성하라.


# 개념과 알고리즘 > 8. 재귀와 동적 프로그래밍 > 5. 

재귀 곱셈:
* 연산자를 사용하지 않고 양의 정수 두 개를 곱하는 재귀 함수를 작성하라.
덧셈(addition), 뺄셈(subtraction), 비트 시프팅(bit shifting) 연산자를 사용할 수 있지만
이들의 사용 횟수를 최소화해야 한다.


# 개념과 알고리즘 > 8. 재귀와 동적 프로그래밍 > 6. 

하노이타워:
전형적인 하노이타워(Towers of Hanoi)에서는
크기가 서로 다른 N개의 원반을 세 개의 기둥 중 아무 곳으로나 옮길 수 있다.
초기에 원은 크기가 맨 위에서부터 아래로 커지는 순서대로 쌓여 있다.
그리고 이 문제에는 다음과 같은 제약조건이 있다.

(1) 원반을 한 번에 하나만 옮길 수 있다.
(2) 맨 위에 있는 원반 하나를 다른 기둥으로 옮길 수 있다.
(3) 원반은 자신보다 크기가 작은 디스크 위에 놓을 수 없다.

스택을 사용하여 모든 원반을 첫 번째 기둥에서 마지막 기둥으로 옮기는 프로그램을 작성하라.


# 개념과 알고리즘 > 8. 재귀와 동적 프로그래밍 > 7. 

중복 없는 순열:
문자열이 주어졌을 때 모든 경우의 순열을 계산하는 메서드를 작성하라.
단, 문자는 중복되어 나타날 수 없다.


# 개념과 알고리즘 > 8. 재귀와 동적 프로그래밍 > 8. 

중복 있는 순열:
문자열이 주어졌을 때 모든 경우의 순열을 계산하는 메서드를 작성하라.
문자는 중복되어 나타날 수 있지만, 나열된 순열은 서로 중복되면 안 된다.


# 개념과 알고리즘 > 8. 재귀와 동적 프로그래밍 > 9. 

괄호:
n-쌍의 괄호로 만들 수 있는 모든 합당한(괄호가 적절히 열리고 닫힌)
조합을 출력하는 알고리즘을 구현하라.

※ 예제
입력: 3
출력: ((())), (()()), (())(), ()(()), ()()()


# 개념과 알고리즘 > 8. 재귀와 동적 프로그래밍 > 10. 

영역 칠하기:
이미지 편집 프로그램에서 흔히 쓰이는 '영역 칠하기(paint fill)' 함수를 구현하라.
영역 칠하기 함수는 화면(색이 칠해진 이차원 배열)과 그 화면상의 한 지점,
그리고 새로운 색상이 주어졌을 때,
주어진 지점과 색이 같은 주변 영역을 새로운 색상으로 다시 색칠한다.


# 개념과 알고리즘 > 8. 재귀와 동적 프로그래밍 > 11. 

코인:
쿼터(25센트), 다임(10센트), 니켈(5센트), 페니(1센트)의 네 가지 동전이 무한히 주어졌을 때,
n센트를 표현하는 모든 방법의 수를 계산하는 코드를 작성하라.


# 개념과 알고리즘 > 8. 재귀와 동적 프로그래밍 > 12. 

여덟 개의 퀸:
8×8 체스판 위에 여덟 개의 퀸(queen)이 서로 잡아 먹히지 않도록 놓을 수 있는
모든 가능한 방법을 출력하는 알고리즘을 작성하라.
즉, 퀸은 서로 같은 행, 열, 대각선 상에 놓이면 안 된다.
여기서 '대각선'은 모든 대각선을 의미하는 것으로,
체스판을 양분하는 대각선 두 개로 한정하지 않는다.


# 개념과 알고리즘 > 8. 재귀와 동적 프로그래밍 > 13. 

박스 쌓기:
너비 w_i, 높이 h_i, 깊이 d_i인 박스 n개가 있다.
상자는 회전시킬 수 없으며, 다른 상자 위에 올려 놓을 수 있다.
단, 아래 놓인 상자의 너비, 높이, 깊이가
위에 놓은 상자의 너비, 높이, 깊이보다 더 클 때에만 가능하다.
이 상자들로 쌓을 수 있는 가장 높은 탑을 구하는 메서드를 작성하라.
탑의 높이는 탑을 구성하는 모든 상자 높이의 합이다.


# 개념과 알고리즘 > 8. 재귀와 동적 프로그래밍 > 14. 

불린값 계산:
0(flase), 1(true), &(AND), |(OR), ^(XOR)로 구성된 불린 표현식과,
원하는 계산 결과(역시 불린 값)가 주어졌을 때,
표현식에 괄호를 적절하게 추가하여 그 값이 원하는 결과값과 같게 만들 수 있는
모든 경우의 개수를 출력하는 함수를 구현하라.

※ 예제
countEval("1^0|0|1", false) → 2
countEval("0&0&0&1^1|0", true) → 10


# 개념과 알고리즘 > 9. 시스템 설계 및 규모 확장성 > 1. 

주식 데이터:
서비스를 하나 구현한다고 하자.
이 서비스는 폐장 시점에 주가 정보(시작가, 종가, 최고가, 최저가)를
최대 1,000개의 클라이언트에게 제공한다.
데이터는 이미 주어져 있고, 어떤 형태로든 저장할 수 있다고 가정해도 좋다.
이 서비스를 어떻게 설계하면 좋겠는가?
여러분은 개발과 배포를 책임져야 하고,
지속적으로 시스템을 모니터링하는 한편 사용자에게 전송되는 정보를 관리해야 한다.
여러분이 생각하는 방법을 설명한 다음,
어떤 접근법을 택했는지 그 접근법을 선택한 이유는 무엇인지 설명하라.
어떤 기술을 사용해도 좋다.
클라이언트 프로그램에 정보를 전송하는 방법도 원하는 대로 선택할 수 있다.


# 개념과 알고리즘 > 9. 시스템 설계 및 규모 확장성 > 2. 

소셜 네트워크:
페이스북이나 링크드인과 같은 대규모 소셜 네트워크를 위한 자료구조는 어떻게 설계하겠는가?
두 사람 사이의 최단 경로를 보여 주는 알고리즘은 어떻게 설계하겠는가?
(가령, 나→밥→수잔→제이슨→당신)


# 개념과 알고리즘 > 9. 시스템 설계 및 규모 확장성 > 3. 

웹 크롤러:
웹에 있는 데이터를 긁어 오는 크롤러(crawler)를 설계할 때,
무한루프(infinite loop)에 빠지는 일을 방지하려면 어떻게 해야 하는가?


# 개념과 알고리즘 > 9. 시스템 설계 및 규모 확장성 > 4. 

중복 URL:
100억 개의 URL이 있다.
중복된 문서를 찾으려면 어떻게 해야 하는가?
여기서 '중복'이란 '같은 URL'이라는 뜻이다.


# 개념과 알고리즘 > 9. 시스템 설계 및 규모 확장성 > 5. 

캐시:
간단한 검색 엔진으로 구현된 웹 서버를 생각해 보자.
이 시스템에선 100개의 컴퓨터가 검색 요청을 처리하는 역할을 하고 있다.
예를 들어 하나의 컴퓨터 집단(cluster of machines)에
processSearch(string query)라는 요청을 보내면 그에 상응하는 검색 결과를 반환해 준다.
하지만 어떤 컴퓨터가 요청을 처리하게 될지는 그때그때 다르며,
따라서 같은 요청을 한다고 같은 컴퓨터가 처리할 거라고 장담할 수 없다.
processSearch 메서드는 아주 고비용이다.
최근 검색 요청을 캐시에 저장하는 메커니즘을 설계하라.
데이터가 바뀌었을 때 어떻게 캐시를 갱신할 것인지 반드시 설명하라.


# 개념과 알고리즘 > 9. 시스템 설계 및 규모 확장성 > 6. 

판매 순위:
한 전자상거래 회사는
가장 잘 팔리는 제품의 리스트(전체에서 그리고 각 목록별로)를 알고 싶어 한다.
예를 들어, 어떤 제품은 전체 제품 중에서 1,056번째로 잘 팔리지만
운동 장비 중에서는 13번째로 잘 팔리고, 안전용품 중에서는 24번째로 잘 팔릴 수 있다.
이 시스템을 어떻게 설계할지 설명하라.


# 개념과 알고리즘 > 9. 시스템 설계 및 규모 확장성 > 7. 

개인 재정 관리자:
개인 재정 관리 시스템(mint.com과 같은)을 어떻게 설계할지 설명하라.
이 시스템은 여러분의 은행 계정과 연동되어 있어야 하며
소비 습관을 분석하고 그에 맞게 적절하게 추천할 수 있어야 한다.


# 개념과 알고리즘 > 9. 시스템 설계 및 규모 확장성 > 8. 

Pastebin:
Pastebin과 같은 시스템을 설계하라.
Pastebin은 텍스트를 입력하면 접속 가능한 임의의 URL을 생성한 뒤 반환해 주는 시스템이다.


# 개념과 알고리즘 > 10. 정렬과 탐색 > 1. 

정렬된 병합:
정렬된 배열 A와 B가 주어진다.
A의 끝에는 B를 전부 넣을 수 있을 만큼 충분한 여유 공간이 있다.
B와 A를 정렬된 상태로 병합하는 메서드를 작성하라.


# 개념과 알고리즘 > 10. 정렬과 탐색 > 2. 

Anagram 묶기:
철자 순서만 바꾼 문자열(anagram)이 서로 인접하도록 문자열 배열을 정렬하는 메서드를 작성하라.


# 개념과 알고리즘 > 10. 정렬과 탐색 > 3. 

회전된 배열에서 검색:
n개의 정수로 구성된 정렬 상태의 배열을
임의의 횟수만큼 회전시켜 얻은 배열이 입력으로 주어진닫고 하자.
이 배열에서 특정한 원소를 찾는 코드를 작성하라.
회전시키기 전, 원래 배열은 오름차순으로 정렬되어 있었다고 가정한다.

※ 예제
입력: {15, 16, 19, 20, 25, 1, 3, 4, 5, 7, 10, 14}에서 5를 찾으라.
출력: 8 (배열에서 5가 위치한 인덱스)


# 개념과 알고리즘 > 10. 정렬과 탐색 > 4. 

크기를 모르는 정렬된 원소 탐색:
배열과 비슷하지만 size 메서드가 없는 Listy라는 자료구조가 있다.
여기에는 i 인덱스에 위치한 원소를 O(1) 시간에 알 수 있는 elementAt(i) 메서드가 존재한다.
만약 i 가 배열의 범위를 넘어섰다면 -1을 반환한다
(이 때문에 이 자료구조는 양의 정수만 지원한다).
양의 정수가 정렬된 Listy가 주어졌을 대, 원소 x의 인덱스를 찾는 알고리즘을 작성하라.
만약 x가 여러 번 등장한다면 아무거나 하나 반환하면 된다.


# 개념과 알고리즘 > 10. 정렬과 탐색 > 5. 

드문드문 탐색:
빈 문자열이 섞여 있는 정렬된 문자열 배열이 주어졌을 때,
특정 문자열의 위치를 찾는 메서드를 작성하라.

※ 예제
입력: ball, {"at", "", "", "", "ball", "", "", "car", "", "", "dad", "", ""}
출력: 4


# 개념과 알고리즘 > 10. 정렬과 탐색 > 6. 

큰 파일 정렬:
한 줄에 문자열 하나가 쓰여 있는 20GB짜리 파일이 있다고 하자.
이 파일을 정렬하려면 어떻게 해야 할지 설명하라.


# 개념과 알고리즘 > 10. 정렬과 탐색 > 7. 

빠트린 정수:
음이 아닌 정수 40억 개로 이루어진 입력 파일이 있다.
이 파일에 없는 정수를 생성하는 알고리즘을 작성하라.
단, 메모리는 1GB만 사용할 수 있다.


# 개념과 알고리즘 > 10. 정렬과 탐색 > 8. 

중복 찾기:
1부터 N(<=32,000)까지의 숫자로 이루어진 배열이 있다.
배열엔 중복된 숫자가 나타날 수 있고, N이 무엇인지는 알 수 없다.
사용 가능한 메모리가 4KB일 때, 중복된 원소를 모두 출력하려면 어떻게 해야 할까?


# 개념과 알고리즘 > 10. 정렬과 탐색 > 9. 

정렬된 행렬 탐색:
각 행과 열이 오름차순으로 정렬된 N×N 행렬이 주어졌을 때,
특정한 원소를 찾는 메서드를 구현하라.


# 개념과 알고리즘 > 10. 정렬과 탐색 > 10. 

스트림에서의 순위:
정수 스트림을 읽는다고 하자.
주기적으로 어떤 수 x의 랭킹(x보다 같거나 작은 수의 개수)을 확인하고 싶다.
해당 연산을 지원하는 자료구조와 알고리즘을 구현하라.
수 하나를 읽을 때마다 호출되는 메서드 track(int x)와 x보다
같거나 작은 수의 개수(x 자신은 제외)를 반환하는 메서드 getRankOfNumber(int x)를 구현하면 된다.

※ 예제
입력 스트림(stream): 5, 1, 4, 4, 5, 9, 7, 13, 3
getRankOfNumber(1) = 0
getRankOfNumber(3) = 1
getRankOfNumber(4) = 3


# 개념과 알고리즘 > 10. 정렬과 탐색 > 11. 

Peak와 Valley:
정수 배열에서 'peak'란 현재 원소가 인접한 상수보다 크거나 같을 때를 말하고,
'valley'란 현재 원소가 인접한 정수보다 작거나 같을 때를 말한다.
예를 들어 {5, 8, 6, 2, 3, 4, 6}이 있으면,
{8, 6}은 'peak'가 되고, {5, 2}는 'valley'가 된다.
정수 배열이 주어졌을 때, 'peak'와 'valley'가 번갈아 등장하도록 정렬하는 알고리즘을 작성하라.


# 개념과 알고리즘 > 11. 테스팅 > 1. 

오류:
다음 코드에서 오류를 찾아내라.

unsigned int i;
for (i = 100; i >= 0; --i)
    printf("%d\n", i);


# 개념과 알고리즘 > 11. 테스팅 > 2. 

무작위 고장:
실행 중 죽어 버리는 프로그램의 소스코드가 있다.
디버거에서 열 번 실행해 본 결과, 같은 지점에서 죽는 일은 없었다.
이 프로그램은 단일 스레드(thread) 프로그램이고, C의 표준 라이브러리만 사용한다.
프로그램에 어떤 오류가 있으면 이런 식으로 죽겠는가?
그 오류들을 각각 어떻게 테스트해 볼 수 있겠는가?


# 개념과 알고리즘 > 11. 테스팅 > 3. 

체스 테스트:
체스 게임에 다음과 같은 메서드가 있다.
boolean canMoveTo(int x, int y).
이 메서드는 Piece 클래스의 일부로, 체스 말이 (x, y) 지점으로 이동할 수 있는지 여부를 알려준다.
이 메서드를 어떻게 테스트할 것인지 설명하라.


# 개념과 알고리즘 > 11. 테스팅 > 4. 

No 테스트 도구:
테스트 도구를 사용하지 않고
웹 페이지에 부하 테스트(load test)를 실행하려면 어떻게 하면 되는가?


# 개념과 알고리즘 > 11. 테스팅 > 5. 

펜 테스트:
펜을 어떻게 테스트하겠는가?


# 개념과 알고리즘 > 11. 테스팅 > 6. 

ATM 테스트:
분산 은행 업무 시스템을 구성하는 ATM을 어떻게 테스트하겠는가?


# 지식 기반 문제 > 12. C와 C++ > 1. 

마지막 K줄:
C++를 사용하여 입력 파일의 마지막 K줄을 출력하는 메서드를 작성하라.


# 지식 기반 문제 > 12. C와 C++ > 2. 

문자열 뒤집기:
C 혹은 C++를 사용하여 null로 끝나는 문자열을 뒤집는 함수 void reverse(char* str)을 작성하라.


# 지식 기반 문제 > 12. C와 C++ > 3. 

해시테이블 vs. STL map:
해시테이블과  STL map을 비교하고 장단점을 논하라.
해시테이블은 어떻게 구현되는가?
입력의 개수가 적다면, 해시테이블 대신 어떤 자료구조를 활용할 수 있겠는가?


# 지식 기반 문제 > 12. C와 C++ > 4. 

가상 함수:
C++의 가상 함수 동작 원리는?


# 지식 기반 문제 > 12. C와 C++ > 5. 

얕은 복사 vs. 깊은 복사:
얕은 복사(shallow copy)와 깊은 복사(deep copy)는 어떻게 다른가?
이 각각을 어떻게 사용할 것인지 설명하라.


# 지식 기반 문제 > 12. C와 C++ > 6. 

Volatile:
C에서 volatile이라는 키워드는 어떤 중요한 의미를 갖는가?


# 지식 기반 문제 > 12. C와 C++ > 7. 

가상 상위 클래스:
상위 클래스의 소멸자를 virtual로 선언해야 하는 이유는 무엇인가?


# 지식 기반 문제 > 12. C와 C++ > 8. 

노드 복사:
Node의 포인터를 인자로 받은 뒤 해당 포인터가 가리키는 객체를 완전히 복사하고
복사된 개체를 반환하는 메서드를 작성하라.
Node 객체 안에는 다른 Node 객체를 가리키는 포인터가 두 개 있다.


# 지식 기반 문제 > 12. C와 C++ > 9. 

스마트 포인터:
스마트 포인터(smart pointer) 클래스를 작성하라.
스마트 포인터는 보통 템플릿으로 구현되는 자료형인데,
포인터가 하는 일을 흉내내면서 쓰레기 수집(garbage collection)과 같은 작업을 처리한다.
즉, 스마트 포인터는 SmartPointer 타입의 객체에 대한 참조 횟수를 자동으로 센 뒤,
T 타입 객체에 대한 참조 개수가 0에 도달하면 해당 객체를 반환한다.


# 지식 기반 문제 > 12. C와 C++ > 10. 

메모리 할당:
반환되는 메모리의 주소가 2의 승수(power of two)로 나누어 지도록
메모리를 할당하고 반환하는 malloc과 free 함수를 구현하라.

※ 예제
align_malloc(1000,128)은 1000바이트 크기의 메모리를 반환하는데,
이 메모리의 주소는 128의 배수다.
aligned_free()는 align_malloc이 할당한 메모리를 반환한다.


# 지식 기반 문제 > 12. C와 C++ > 11. 

2D 할당:
my2DALLoc이라는 함수를 C로 작성하라.
이 함수는 2차원 배열을 할당하는데,
malloc 호출 횟수는 최소화하고 반환된 메모리를 arr[i][j]와 같은 형태로 사용할 수 있어야 한다.


# 지식 기반 문제 > 13. 자바 > 1. 

private 생성자:
상속 관점에서 생성자를 private로 선언하면 어떤 효과가 있나?


# 지식 기반 문제 > 13. 자바 > 2. 

finally에서의 귀환:
자바의 finally 블록은 try-catch-finally의 try 블록 안에 return 문을 넣어도 실행되는가?


# 지식 기반 문제 > 13. 자바 > 3. 

final과 그 외:
final, finally, finalize의 차이는?


# 지식 기반 문제 > 13. 자바 > 4. 

제네릭 vs. 템플릿:
자바 제네릭(generic)과 C++ 템플릿(template)의 차이를 설명하라.


# 지식 기반 문제 > 13. 자바 > 5. 

TreeMap, HashMap, LinkedHashMap:
TreeMap, HashMap, LinkedHashMap의 차이를 설명하라.
언제 무엇을 사용하는 것이 좋은지 예를 들어 설명하라.


# 지식 기반 문제 > 13. 자바 > 6. 

객체 리플렉션:
자바의 객체 리플렉션(object reflection)을 설명하고, 이것이 유용한 이유를 나열하라.


# 지식 기반 문제 > 13. 자바 > 7. 

람다표현식:
Country라는 클래스에 getContinent()와 getPopulation()이라는 메서드가 있다.
대륙의 이름과 국가의 리스트가 주어졌을 때 주어진 대륙의 총 인구수를 계산하는 메서드
getPopulation(List<Contry> countries, String continent)를 작성하라.


# 지식 기반 문제 > 13. 자바 > 8. 

람다 랜덤:
람다(lambda)표현식을 사용해서 임의의 부분집합을 반환하는 함수
List getRandomSubset(List<Integer> list)를 작성하라.
공집합을 포함한 모든 부분집합이 선택될 확률은 같아야 한다.


# 지식 기반 문제 > 14. 데이터베이스 > 1. 

하나 이상의 집:
하나 이상의 집을 대여한 모든 거주자의 목록을 구하는 SQL 질의문을 작성하라.


# 지식 기반 문제 > 14. 데이터베이스 > 2. 

Open 상태인 Request:
모든 건물 목록과 Status가 Open인 모든 Request의 개수를 구하라.


# 지식 기반 문제 > 14. 데이터베이스 > 3. 

Request를 Close로 바꾸기:
11번 빌딩에서 대규모 리모델링 공사를 진행 중이다.
이 건물에 있는 모든 집에 대한 모든 Request의 Status를 Close로 변경해주는 질의문을 작성하라.


# 지식 기반 문제 > 14. 데이터베이스 > 4. 

JOIN:
서로 다른 종류의 JOIN은 어떤 것들이 있는가?
각각이 어떻게 다르고, 어떤 상황에서 어떤 JOIN과 어울리는지 설명하라.


# 지식 기반 문제 > 14. 데이터베이스 > 5. 

비정규화:
비정규화(denormalization)란 무엇인가? 그 장단점을 설명하라.


# 지식 기반 문제 > 14. 데이터베이스 > 6. 

개체-관계 다이어그램:
회사, 사람, 직원으로 구성된 데이터베이스의 ER(entity-relationship) 다이어그램을 그리라.


# 지식 기반 문제 > 14. 데이터베이스 > 7. 

성적 데이터베이스 설계:
학생들의 성적을 저장하는 간단한 데이터베이스를 생각해 보자.
이 데이터베이스를 설계하고, 성적이 우수한 학생(상위 10%) 목록을 반환하는 SQL 질의문을 작성하라.
단, 학생 목록은 평균 성적에 따라 내림차순으로 정렬되어야 한다.


# 지식 기반 문제 > 15. 스레드와 락 > 1. 

프로세스 vs. 스레드:
프로세스와 스레드의 차이는 무엇인가?


# 지식 기반 문제 > 15. 스레드와 락 > 2. 

문맥 전환:
문맥 전환(context switch)에 소요되는 시간을 측정하려면 어떻게 해야 할까?


# 지식 기반 문제 > 15. 스레드와 락 > 3. 

철학자의 만찬:
유명한 철학자의 만찬 문제(dining philosophers problem)를 떠올려 보자.
철학자들은 원형 테이블에 앉아 있고 그들 사이에 젓가락 한 짝이 놓여 있다.
음식을 먹으려면 젓가락 두 짝이 전부 필요한데,
철학자들은 언제나 오른쪽 젓가락을 집기 전에 왼쪽 젓가락을 먼저 집는다.
모든 철학자들이 왼쪽에 있는 젓가락을 동시에 집으려고 하면, 교착상태에 빠질 수 있다.
철학자들의 만찬 문제를 시뮬레이션하는 프로그램을 작성하라.
단, 스레드와 락을 사용하여 이 프로그램이 교착상태에 빠지지 않도록 하라.


# 지식 기반 문제 > 15. 스레드와 락 > 4. 

교착상태 없는 클래스:
교착상태에 빠지지 않는 경우에만 락을 제공해주는 클래스를 설계해 보라.


# 지식 기반 문제 > 15. 스레드와 락 > 5. 

순서대로 호출:
다음과 같은 코드가 있다고 하자.

public class Foo {
    public Foo() { ... }
    public void first() { ... }
    public void second() { ... }
    public void third() { ... }
}

Foo 인스턴스 하나를 서로 다른 세 스레드에 전달한다.
threadA는 first를 호출할 것이고,
threadB는 second를 호출할 것이며,
threadC는 third를 호출할 것이다.
first가 second보다 먼저 호출되고,
second가 third보다 먼저 호출되도록 보장하는 메커니즘을 설계하라.


# 지식 기반 문제 > 15. 스레드와 락 > 6. 

동기화된 메서드:
동기화된 메서드 A와 일반 메서드 B가 구현된 클래스가 있다.
같은 프로그램에서 실행되는 스레드가 두 개 존재할 때 A를 동시에 실행할 수 있는가?
A와 B는 동시에 실행될 수 있는가?


# 지식 기반 문제 > 15. 스레드와 락 > 7. 

FizzBuzz:
FizzBuzz라는 고전적인 문제가 있다.
여러분은 1부터 n까지 출력하는 프로그램을 작성해야 한다.
3으로 나누어 떨어질 땐 "Fizz"를, 5로 나누어 떨어질 땐 "Buzz"를 출력해야 하고,
3과 5 둘 다로 나누어 떨어지면 "FizzBuss"를 출력해야 한다.
여기에선 다중 스레드(multi-thread)를 이용해서 문제를 풀어 볼 것이다.
여러분은 4개의 스레드를 사용해야 하는데,
첫 번째 스레드는 3으로 나누어 떨어지는지 확인한 뒤 나누어 떨어지면 "Fizz"를 출력해야 하고,
두 번째 스레드는 5로 나누어 떨어지는지 확인한 뒤 나누어 떨어지면 "Buzz"를 출력해야 하고,
세 번째 스레드는 동시에 3과 5로 나누어 떨어지는지 확인한 뒤 나누어 떨어지면
"FizzBuzz"를 출력해야 하고, 네 번재 스레드는 그 외의 숫자를 출력해야 한다.


# 16. 중간 난이도 연습문제 > 1. 


# 17. 어려운 연습문제 > 1. 


# 고급 주제 > 유용한 수학


# 고급 주제 > 위상정렬


# 고급 주제 > 다익스트라 알고리즘


# 고급 주제 > 해시테이블에서 충돌을 해결하는 방법


# 고급 주제 > 선형 탐사법을 이용한 개방 주소법


# 고급 주제 > Rabin-Karp 부분 문자열 탐색 알고리즘


# 고급 주제 > AVL 트리


# 고급 주제 > 레드-블랙 트리


# 고급 주제 > MapReduce


# 고급 주제 > 추가 공부거리


# 코드 라이브러리 > HashMapList[T, E]


# 코드 라이브러리 > TreeNode(이진 탐색 트리)


# 코드 라이브러리 > LinkedListNode(연결리스트)


# 코드 라이브러리 > Trie & TrieNode



----------< 알고리즘 문제 해결 전략 세트(인사이트) >----------



----------< 도서 : 밑바닥부터 시작하는 딥러닝(한빛미디어) >----------



----------< 도서 : 밑바닥부터 시작하는 딥러닝2(한빛미디어) >----------



----------< 도서 : 블록과 함께하는 파이썬 딥러닝 케라스(디지털북스) >----------



----------< 도서 : 케라스 창시자에게 배우는 딥러닝(길벗) >----------

# 머신러닝의 정의
- 일반적 정의 : 명시적인 프로그래밍 없이 컴퓨터가 학습하는 능력을 갖추게 하는 연구 분야다.
- 공학적 정의 : 어떤 작업 T에 대한 컴퓨터 프로그램의 성능을 P로 측정했을 때 경험 E로 인해
               성능이 향상됐다면, 이 컴퓨터 프로그램은 작업 T와 성능 측정 P에 대해
               경험 E로 학습한 것이다.


# 머신러닝의 탁월분야
- 기존 솔루션으로는 많은 수동 조정과 규칙이 필요한 문제
- 전통적인 방법으로는 전혀 해결책이 없는 복잡한 문제
- 유동적인 환경
- 복잡한 문제와 대량의 데이터에서 통찰 얻기


# 학습의 종류
- 지도학습 / 비지도학습 / 강화학습 : 사람의 감독 유무
- 온라인학습 / 배치학습(오프라인학습) : 실시간 여부
- 사례기반학습 / 모델기반학습 : 기존 데이터와의 비교 or 새로운 패턴 발견


# 머신러닝의 주요도전과제
- 부족한 데이터, 낮은 데이터 품질, 대표성 없는 데이터, 무의미한 특성, 과소적합&과대적합


# 모델 평가
- 훈련 & 검증 & 테스트 세트
- 검증 세트의 목적 : 모델 비교
- 테스트 세트의 목적 : 오차 추정
- 교차검증 : 훈련세트를 여러 subset으로 나누어 그 조합으로 훈련시키고 나머지 부분으로 검증


# 보편적인 머신러닝 작업 흐름
- 문제 정의와 데이터셋 수집 : 입력, 출력, 데이터, 가설 등의 설정
- 성공 지표 선택 : 정확도, ROC AUC
- 평가 방법 선택
    Hold-out Validation(홀드아웃 검증) : 데이터가 풍부할 때
    K-fold Cross-Validation(K-겹 교차 검증) : 샘플의 수가 너무 적을 때
    Iterated K-fold Cross-Validation(반복 K-겹 교차 검증) : 데이터가 적고 매우 정확한 모델 평가가 필요할 때
- 데이터 준비
    [-1, 1] 또는 [0, 1] 범위의 작은 스케일의 텐서
    특성마다 범위가 다르면 정규화 필요
    데이터가 적으면 특성 공학을 수행
- 모델 훈련(문제 유형 / 마지막 층의 활성화 함수 / 손실 함수)
    이진 분류 / 시그모이드 / binary_crossentropy
    단일 레이블 다중 분류 / 소프트맥스 / categorical_crossentropy
    다중 레이블 다중 분류 / 시그모이드 / binary_crossentropy
    임의 값에 대한 회귀 / 없음 / mse
    0과 1 사이 값에 대한 회귀 / 시그모이드 / mse 또는 binary_crossentropy
- 과대적합 모델 구축 : 층의 수 증가, 층의 크기 증가, 에포크 수 증가
- 모델 규제와 하이퍼파라미터 튜닝
    드룹아웃을 추가
    층을 추가하거나 제거해서 다른 구조로 재시도
    L1 이나 L2 또는 두 가지 모두 추가
    하이퍼파라미터 수정
    특성 공학을 수행


# 텐서
- 차원(축, rank)
    0D(스칼라)
    1D(벡터)
    2D(행렬)
    3D : 시계열 또는 시퀀스 데이터
    4D : 이미지
    5D : 동영상
- 크기(shape)
- 타입(dtype)

넘파이에서이 3D 텐서의 예
x = np.array([[[5, 78, 2, 34, 0],
               [6, 79, 3, 35, 1],
               [7, 80, 4, 36, 2]],
              [[5, 78, 2, 34, 0],
               [6, 79, 3, 35, 1],
               [7, 80, 4, 36, 2]]])
x.ndim # 3
x.shape # (2, 3, 5)
x.dtype # uint8


# 벡터와 벡터의 점곱
def naive_vector_dot(x, y):
    assert len(x.shape) == 1
    assert len(y.shape) == 1
    assert x.shape[0] == y.shape[0]

    z = 0.
    for i in range(x.shape[0]):
        z += x[i] * y[i]
    return z


# 행렬과 벡터의 점곱
import numpy as np
def naive_matrix_vector_dot(x, y): # naive_vector_dot를 재사용 안 하는 경우
    assert len(x.shape) == 2
    assert len(y.shape) == 1
    assert x.shape[1] == y.shape[0]

    z = np.zeros(x.shape[0]) # x의 행과 같은 크기의 0이 채워진 벡터를 생성
    for i in range(x.shape[0]):
        for j in range(x.shape[1]):
            z[i] += x[i, j] * y[j]
    return z

def naive_matrix_vector_dot(x, y): # naive_vector_dot를 재사용 하는 경우
    z = np.zeros(x.shape[0])
    for i in range(x.shape[0]):
        z[i] = naive_vector_dot(x[i, :], y)
    return z


# 행렬과 행렬의 점곱
import numpy as np
def naive_matrix_dot(x, y):
    assert len(x.shape) == 2
    assert len(y.shape) == 2
    assert x.shape[1] == y.shape[0]

    z = np.zeros((x.shape[0], y.shape[1]))
    for i in range(x.shape[0]):
        for j in range(y.shape[1]):
            row_x = x[i, :]
            column_y = y[:, j]
            z[i, j] = naive_vector_dot(row_x, column_y)
    return z


# 텐서 크기 변환
x = np.array([[0., 1.],
              [2., 3.],
              [4., 5.]])
print(x.shape) # (3, 2)
x = x.reshape((2, 3))

y = np.zeros((300, 20))
y = np.transpose(y)
print(y.shape) # (20, 300)


# SGD(Stochastic Gradient Descent, 확률적 경사 하강법)
past_velocity = 0.
momentum = 0.1
while loss > 0.01:
    w, loss, gradient = get_current_parameters()
    velocity = momentum * past_velocity - learning_rate * gradient
    w = w + momentum * velocity - learning_rate * gradient
    past_velocity = velocity
    update_parameter(w)

# 딥러닝 코드?



----------< 도서 : 파이썬 머신러닝 완벽가이드(위키북스) >----------



----------< 도서 : 파이썬 라이브러리를 활용한 머신러닝(한빛미디어) >----------



----------< 도서 : 파이썬 라이브러리를 활용한 데이터분석(한빛미디어) >----------



----------< 강좌 : 모두의 딥러닝 시즌2(김성훈) >----------


